<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Financial Chatbot</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <style>
    body {
      font-family: 'Segoe UI', Roboto, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #f5f7f9;
      color: #333;
      margin: 0; padding: 0;
      display: flex; flex-direction: column; height: 100vh;
    }
    header {
      background: #1e3a8a;
      color: white;
      padding: 1rem;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #chat-box {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      background: #f5f7f9;
      display: flex;
      flex-direction: column;
    }
    p.bot, p.system {
      background: white;
      padding: 0.8rem 1.2rem;
      border-radius: 18px;
      border-top-left-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      max-width: 75%;
      margin: 0.5rem 0;
      line-height: 1.5;
      color: #333;
      align-self: flex-start;
      position: relative;
    }
    p.user {
      background: #1e3a8a;
      padding: 0.8rem 1.2rem;
      border-radius: 18px;
      border-top-right-radius: 4px;
      color: white;
      max-width: 75%;
      margin: 0.5rem 0;
      line-height: 1.5;
      align-self: flex-end;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    /* New: Agent message style for customer's UI */
    p.agent {
      background: #4f46e5; /* Indigo color for agent messages */
      padding: 0.8rem 1.2rem;
      border-radius: 18px;
      border-top-left-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      max-width: 75%;
      margin: 0.5rem 0;
      line-height: 1.5;
      color: white;
      align-self: flex-start;
      position: relative;
    }

    p.bot strong, p.agent strong { /* Apply to agent messages too */
      color: #1e3a8a; /* Consistent color for bold */
      font-weight: 600;
    }
    p.bot ul, p.agent ul {
      list-style-type: disc;
      margin-left: 1.5rem;
      padding-left: 0;
    }
    p.bot li, p.agent li {
      margin-bottom: 0.5rem;
    }
    #input-area {
      display: flex;
      background: white;
      padding: 1rem;
      border-top: 1px solid #e5e7eb;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
      align-items: center;
    }
    #user-input {
      flex: 1;
      padding: 0.8rem 1.2rem;
      border: 1px solid #d1d5db;
      border-radius: 24px;
      font-size: 1rem;
      background: white;
      color: #333;
      resize: none;
      overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
      transition: border-color 0.2s;
    }
    #user-input:focus {
      outline: none;
      border-color: #1e3a8a;
      box-shadow: 0 0 0 2px rgba(30,58,138,0.2);
    }
    button.send-button {
      background: #1e3a8a;
      border: none;
      border-radius: 50%;
      width: 42px;
      height: 42px;
      color: white;
      margin-left: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      flex-shrink: 0;
    }
    button.send-button:hover {
      background: #283b8a;
    }

    button.option-button {
      margin: 0.3rem;
      padding: 0.7rem 1.5rem;
      background: white;
      border: 1px solid #1e3a8a;
      border-radius: 24px;
      color: #1e3a8a;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    button.option-button:hover {
      background: #1e3a8a;
      color: white;
    }
    .options-container, .feedback-container {
      margin: 1rem 0;
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%; /* Ensure they take full width in the flex container */
    }
    button.feedback-button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid #e5e7eb;
      cursor: pointer;
      background-color: white;
      color: #6b7280;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    button.feedback-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    button.feedback-button.positive:hover {
      background-color: #ecfdf5;
      color: #10b981;
      border-color: #10b981;
    }
    button.feedback-button.negative:hover {
      background-color: #fef2f2;
      color: #ef4444;
      border-color: #ef4444;
    }
    #loader {
      display: none;
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background: white;
      border-radius: 18px;
      width: fit-content;
      margin: 0.5rem 0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #d1d5db;
      border-radius: 50%;
      display: inline-block;
      animation: typing 1.4s infinite ease-in-out both;
    }
    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typing {
      0%, 100% { transform: scale(0.7); opacity: 0.5; }
      50% { transform: scale(1); opacity: 1; }
    }
    
    .message-time {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 0.3rem;
      text-align: right;
      color: #fefefe; /* For user messages */
    }
    p.bot .message-time, p.system .message-time {
        color: #6b7280; /* For bot/system messages */
    }
    p.agent .message-time {
      color: #fefefe; /* For agent messages */
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <header>
    <h1>Financial Assistant</h1>
  </header>
  <div id="chat-box"></div>
  <div id="loader" class="typing-indicator">
    <span></span><span></span><span></span>
  </div>
  <div id="input-area">
    <div id="quick-options" class="options-container">
      <!-- Quick options will be inserted here -->
    </div>
    <textarea id="user-input" rows="1" placeholder="Type your message and press Enter..."></textarea>
    <button class="send-button" onclick="handleUserInput()">
      <i class="fas fa-paper-plane"></i>
    </button>
  </div>

  <script>
    // 'stage' now controls the conversation flow:
    // 0 = Initial query, or authenticated general chat
    // 1 = Waiting for Account ID
    // 2 = Waiting for OTP
    // 3 = Authenticated and ready for direct queries (after OTP verification completes successfully)
    let currentAuthStage = 0; 
    let chatHistory = [];
    let pendingIntent = ""; // To store the user's initial intent (emi, balance, loan, agent_escalation)
    let lastMessageCheckTime = new Date().toISOString(); // For polling agent messages

    window.onload = function () {
      const userInput = document.getElementById("user-input");
      userInput.addEventListener("input", function() {
          this.style.height = "auto";
          this.style.height = (this.scrollHeight) + "px";
      });

      userInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleUserInput();
        }
      });
      
      // Initial welcome message and options
      addMessage("Hello! I am your financial assistant. How can I assist you today?", 'bot');
      showOptions();

      // If user is already authenticated (e.g., from a previous session or refresh),
      // start polling for agent messages.
      if (localStorage.getItem('customer_id')) {
        startCheckingForAgentMessages();
      }
    };

    /**
     * Adds a message to the chat display.
     * Uses textContent for security (XSS prevention).
     * @param {string} msg The message text.
     * @param {string} sender The sender ('user', 'bot', 'system', 'agent').
     * @param {Date} [timestamp=new Date()] The timestamp of the message.
     */
    function addMessage(msg, sender, timestamp = new Date()) {
      const chatBox = document.getElementById("chat-box");
      const messageElement = document.createElement("p");
      messageElement.className = sender;
      
      // Use textContent for security, unless specifically parsing markdown from bot
      if (sender === 'bot') {
        // Only parse markdown for bot messages (assuming they are controlled and safe)
        messageElement.innerHTML = marked.parse(msg); 
      } else {
        messageElement.textContent = msg; // Sanitize user and system messages
      }
      
      const timeElement = document.createElement("div");
      timeElement.className = "message-time";
      timeElement.textContent = formatTime(timestamp);
      messageElement.appendChild(timeElement);
      
      chatBox.appendChild(messageElement);
      chatBox.scrollTop = chatBox.scrollHeight;
      
      // Only add user/bot/agent messages to chatHistory for summarization
      if (sender !== 'system') {
        chatHistory.push({ sender: sender, content: msg, timestamp: timestamp.toISOString() });
      }
    }
    
    /**
     * Formats a Date object into a readable time string.
     * @param {Date} date The Date object to format.
     * @returns {string} Formatted time string (e.g., "09:30 AM").
     */
    function formatTime(date) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    /**
     * Displays quick option buttons for the user.
     */
    function showOptions() {
      const quickOptions = document.getElementById("quick-options");
      quickOptions.innerHTML = ''; // Clear existing options
      quickOptions.style.display = 'flex'; // Show the container (flexbox)

      const options = [
        { text: "My EMI", value: "What is my EMI?" },
        { text: "My Account Balance", value: "What is my account balance?" },
        { text: "My Loan Amount", value: "What is my loan amount?" },
        { text: "Speak to Agent", value: "I need to speak to an agent." }
      ];

      options.forEach(option => {
        const button = document.createElement("button");
        button.className = "option-button";
        button.textContent = option.text;
        button.onclick = () => handleOption(option.value, option.text);
        quickOptions.appendChild(button);
      });
      // Ensure input area and send button are visible and ready
      document.getElementById('user-input').disabled = false;
      document.getElementById('user-input').placeholder = "Type your message and press Enter...";
      document.querySelector('.send-button').disabled = false;
      document.getElementById('user-input').focus();
    }

    /**
     * Hides quick option buttons.
     */
    function hideOptions() {
      document.getElementById("quick-options").innerHTML = '';
      document.getElementById("quick-options").style.display = 'none';
    }

    /**
     * Handles clicks on quick option buttons.
     * @param {string} value The value to send to the backend (e.g., "emi").
     * @param {string} label The display text of the button (e.g., "My EMI").
     */
    function handleOption(value, label) {
      addMessage(label, 'user');
      hideOptions();
      // Set the pending intent based on the option clicked
      pendingIntent = value; 
      // Process the message via the main handler
      handleUserInput(value); 
    }

    /**
     * Main function to handle user input (typed or option clicked).
     */
    async function handleUserInput(optionValue = null) {
      let message;
      if (optionValue) {
        message = optionValue;
      } else {
        const userInputField = document.getElementById("user-input");
        message = userInputField.value.trim();
        userInputField.value = "";
        userInputField.style.height = "auto";
      }

      if (!message) return;

      // Add user message to UI if not from option button already added by handleOption
      if (!optionValue) {
        addMessage(message, 'user');
      }
      hideOptions(); // Hide options once user sends a message

      showLoader(true);

      try {
        const response = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: message,
            chat_history: chatHistory.map(entry => ({ sender: entry.sender, content: entry.content }))
          })
        });

        const data = await response.json();
        const botResponse = data.response;
        currentAuthStage = data.auth_state;
        const actionNeeded = data.action_needed;

        if (botResponse) {
          addMessage(botResponse, 'bot');
        } else {
          addMessage("I apologize, I couldn't process your request. Please try again.", 'bot');
        }

        // Handle next steps based on backend's actionNeeded and authState
        if (actionNeeded === "awaiting_account_id") {
            document.getElementById('user-input').placeholder = "Please enter your Account ID...";
            document.getElementById('user-input').disabled = false;
            document.querySelector('.send-button').disabled = false;
            document.getElementById('user-input').focus();
        } else if (actionNeeded === "awaiting_otp") {
            document.getElementById('user-input').placeholder = "Please enter the OTP...";
            document.getElementById('user-input').disabled = false;
            document.querySelector('.send-button').disabled = false;
            document.getElementById('user-input').focus();
        } else if (actionNeeded === "authenticated" || actionNeeded === "none") {
            // After successful auth or for general queries
            document.getElementById('user-input').placeholder = "Type your message and press Enter...";
            document.getElementById('user-input').disabled = false;
            document.querySelector('.send-button').disabled = false;
            showFeedbackButtons(); // Show feedback for final responses
        } else if (actionNeeded === "escalated") {
            document.getElementById('user-input').placeholder = "Connecting to agent...";
            document.getElementById('user-input').disabled = true;
            document.querySelector('.send-button').disabled = true;
            addMessage("You are now connected with a live agent. Please wait for their response.", 'system');
            startCheckingForAgentMessages(); // Start polling for agent replies
        }

      } catch (error) {
        console.error('Error sending message:', error);
        addMessage("I'm having trouble connecting. Please check your internet and try again.", 'bot');
        showFeedbackButtons(); // Allow user to provide feedback even on errors
      } finally {
        showLoader(false);
      }
    }

    /**
     * Shows/hides the typing indicator.
     * @param {boolean} show True to show, false to hide.
     */
    function showLoader(show) {
      const loader = document.getElementById("loader");
      loader.style.display = show ? "flex" : "none"; // Use flex for typing indicator animation
    }

    /**
     * Displays feedback buttons after a bot response.
     */
    function showFeedbackButtons() {
      // Remove any existing feedback container to prevent duplicates
      document.querySelector(".feedback-container")?.remove();

      const chatBox = document.getElementById("chat-box");
      const feedbackContainer = document.createElement("div");
      feedbackContainer.className = "options-container feedback-container"; // Use options-container styles

      const positiveBtn = document.createElement("button");
      positiveBtn.className = "feedback-button positive";
      positiveBtn.innerHTML = '<i class="fas fa-thumbs-up"></i>';
      positiveBtn.title = "Helpful";
      positiveBtn.onclick = () => sendFeedback(true);

      const negativeBtn = document.createElement("button");
      negativeBtn.className = "feedback-button negative";
      negativeBtn.innerHTML = '<i class="fas fa-thumbs-down"></i>';
      negativeBtn.title = "Not Helpful";
      negativeBtn.onclick = () => sendFeedback(false);

      feedbackContainer.appendChild(positiveBtn);
      feedbackContainer.appendChild(negativeBtn);
      chatBox.appendChild(feedbackContainer);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    /**
     * Sends user feedback and triggers agent escalation if needed.
     * @param {boolean} isUseful - True if the response was helpful, false otherwise.
     */
    async function sendFeedback(isUseful) {
      document.querySelector(".feedback-container")?.remove(); // Remove feedback buttons immediately
      addMessage("Thank you for your feedback!", 'bot');

      if (!isUseful) {
        addMessage("I've logged this conversation for review by a human agent to help improve my responses. Initiating agent handoff...", 'system');
        showLoader(true);
        try {
          const response = await fetch("/chat", { // Send a message to /chat indicating escalation
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message: "I need to speak to an agent.", // Simulate agent request
              chat_history: chatHistory.map(entry => ({ sender: entry.sender, content: entry.content }))
            }),
          });
          const data = await response.json();
          addMessage(data.response, 'bot');
          if (data.action_needed === 'escalated') {
              document.getElementById('user-input').placeholder = "Connecting to agent...";
              document.getElementById('user-input').disabled = true;
              document.querySelector('.send-button').disabled = true;
              startCheckingForAgentMessages(); // Start polling for agent replies
          }
        } catch (err) {
          console.error("Error initiating agent handoff:", err);
          addMessage("Error initiating agent handoff. Please try again later or contact support directly.", 'system');
        } finally {
          showLoader(false);
          // Do NOT reset to initial state immediately if escalated, wait for agent
          if (!isUseful) return; // If escalated, don't show "Is there anything else"
          resetToInitialState();
        }
      } else {
        resetToInitialState(); // For helpful feedback, reset and offer more help
      }
    }

    /**
     * Resets the chat interface to its initial state, prompting for further interaction.
     */
    function resetToInitialState() {
      setTimeout(() => {
          addMessage("Is there anything else I can help you with?", 'bot');
          currentAuthStage = 3; // Stay authenticated if session is valid
          pendingIntent = ""; // Clear any pending intents
          showOptions(); // Show main options again
      }, 1500);
    }

    /**
     * Starts polling for new agent messages if customer is authenticated.
     */
    function startCheckingForAgentMessages() {
        // Prevent multiple intervals from running
        if (window.agentMessageInterval) return;

        window.agentMessageInterval = setInterval(async () => {
            const customer_id = localStorage.getItem('customer_id');
            const session_id = localStorage.getItem('chat_session_id'); // This might need to be stored in localStorage too if persistent sessions

            if (!customer_id || !session_id) {
                console.warn("Cannot check for agent messages: customer_id or session_id missing from localStorage.");
                clearInterval(window.agentMessageInterval);
                window.agentMessageInterval = null;
                return;
            }

            try {
                const response = await fetch('/agent/check_customer_messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customer_id: customer_id,
                        session_id: session_id,
                        last_check_time: lastMessageCheckTime
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.messages && data.messages.length > 0) {
                        data.messages.forEach(msg => {
                            addMessage(msg.message_text, 'agent', new Date(msg.timestamp));
                        });
                        // Update lastMessageCheckTime to the timestamp of the very last message received
                        lastMessageCheckTime = data.messages[data.messages.length - 1].timestamp;
                    }
                } else {
                    console.error('Failed to poll for agent messages:', response.status);
                }
            } catch (error) {
                console.error('Error during agent message polling:', error);
            }
        }, 3000); // Poll every 3 seconds
    }

  </script>
</body>
</html>
